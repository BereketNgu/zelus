let hybrid int(z, x', x0) =
  let der x = x' init x0 reset z -> x0 in
  x

let hybrid combine(f)(g)(z) = (x,y) where
  rec init x = 42.0
  and init y = 0.0
  and y = run f (z, x, last x)
  and x = run g (z, y, last y)
      
let hybrid main(z) = combine(int)(int)(z)

let node compose1(f)(g)(x) = run f(run g(x))

let hybrid compose2(f)(g)(x, z) =
  let o = run f x in
  present z -> o + run g(x) init 0
	      
let node fix(f)(x) = let rec o = run f(x, o) in o

let node f(x, y) = x -> pre(x + y)

let node min(x, y) =
  x -> if pre y < x then pre y else x
  
let node main2(x) = fix(f)(x)

let node main3(x) = fix(min)(x)
    
