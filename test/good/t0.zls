(*
../../compiler/zeluc.byte -v -s ff t0.zls

ocamlfind ocamlc bigarray.cma -package sundialsml sundials.cma zllib.cma -I ../../lib t0.ml ff.ml *)

open Node

    
let hybrid f() =
  let rec der x = 1.0 init -1.0
  and o = present up(x) -> 42.0 init 0.0 in
  (present (period(0.0|2.0)) -> (print_string "x at period = ";
				 print_float x;print_newline ();flush stdout)
      init ());
  (x, o)
      
let node ff () =
  let { time = time; status = status; result = (x, o) } =
    Node.solve f 10.0 (10.0, ()) in
  match status with
  | _ -> () (* print_string "x = "; print_float x; print_newline ();
         print_string "o = "; print_float o; print_newline () *)
    
(*

let hybrid g() =
  let rec der x = 1.0 init -1.0
  and o = present up(x) -> (print_float x; print_newline ()) init () in
  ()

let node main2() =
  let { time = time; status = status; result = r } = solve f 10.0 (100.0, ()) in
  match status with
  | Success -> print_string "success\n"
  | RootsFound -> print_string "root\n"
  | Horizon _ -> print_string "horizon\n"
  | Cascade ->
      let x, o = r in
      (print_string "x = "; print_float x;
       print_newline ();
       print_string "o = "; print_float o;
       print_newline ())
  | StopTimeReached -> print_string "finished\n"
  | Error -> print_string "error"
 *)
	
(* let hybrid main () =
  let o = f() in
  present (period(0.0|2.0)) -> print_float o init ()
 *)
	
(*
let node integr (dt, x') = x where
  rec x = 0.0 -> dt *. x' +. (pre x)
		  *)

    
(*
let node main () =
  let rec next_t, r = Node.solve f 20.0 (20.0, 20.0) in
  match r with
  | Node.Cascade(v) -> (print_float v; print_newline ())
  | _ -> (print_string "Horizon = "; print_float next_t; print_newline ())
 *)
  
    (*

let node f(x26, y26) =
  let rec
      a22, b23 = e21
  and
      y25 = a22
  and
      e21 = (x26, y26)
  and
      e22 = a22 + b23 in
  a22, b23, y25, e21, e22 *)

(* let node f1(x, y) = (z, t) where
   rec z = 0 fby x + 1
   and t = z

let node main () = (o1, o2) where
  rec
   o1 = f1(o2)
  and
   o2 = f1(o1) *)
   
    
(*
let hybrid g(z) =
  let rec init x = 0
  and present z -> do x = 1 done
  and present (disc(last x)) -> do () = print_int x done in
  x
 *)
    
(*
type cstate =
    { cvec: float array;
      dvec: float array;
      zin: float array;
      zout: bool array;
      mutable cpos : int;
      mutable zpos : int }
      
let int = machine(continuous) (g) { 
  memories
    i_15 : bool = false; cont xprime_13 : float = 0.; cont x_12 : float = 0.
    m : cstate; csize : int; zsize : int;
    
  method reset () =
    i_15 <- true;
    xprime_13.pos <- 0.
    
  method step ((time_14:float), ((x0_10:float), (xsecond_11:float))) =
    (((if i_15 then x_12.pos <- x0_10);
      i_15 <- false;
      xprime_13.der <- xsecond_11;
      x_12.der <- xprime_13.pos;
      g.dvec.(g.cpos) <- xsecond_11;
      g.dvec.(g.cpos + 1) <- xprime_13.pos;
      g.cpos <- g.cpos + 2;
      float)]}

   method csize = 2

   method zsize = 0
       *)
      
