(* let hybrid f (x, z) =
  let rec der o = x +. 1.0 init 42.0 reset z -> last o +. 1.0 in
  let o1 = up(x +. 3.0) in
  let der m = o +. 4.0 init 43.0 in
  o1, m +. o +. 2.0
 *)

let hybrid g (c) = o where
forall i in 0 .. 43, oi out o do
  der oi = 1.0 and init oi = 0.0
  done

(* let hybrid h () = o where
  forall i in 0 .. 42, oi out o do
    forall j in 0 .. 43, oij out oi do
      der oij = 1.0 and init oij = 0.0
    done
    done *)
  	
(*
let hybrid g (x, z) =
  let rec present z -> do o = last o +. 1.0 done
          else do der o = x +. 1.0 done
  and init o = 42.0 in
  o +. 2.0

let hybrid h(x) =
  let rec o = up(x +. 1.0) in
  o, o*)
    
    (*
let node g x = o where
  rec automaton
  | S1 -> do o = 1 done
  | S2(x) -> do o = x+2 done
  end*)
  

(* let node micro_step_delay(x) = o where
  rec automaton
      | Await -> do r = 0 unless x(v) then Run(v)
      | Run(v) -> do r = v unless true then do emit o = v in Await
      end

let node micro_step_delay_weak(x) = o where
  rec automaton
      | Await -> do r = 0 until x(v) then Run(v)
      | Run(v) -> do r = v until true then do emit o = v in Await
      end *)

(*
let node g(x) = o where
  rec automaton
      | Await -> do o = 0 unless x(v) then Run(v)
      | Run(v) -> do o = v unless true then Run(v+1)
      end
*)

(* 
let node fix(f)(x) = let rec y = f (x, y) in y

let node integr(x) = 0 fby x + 1

let node f() =
  let rec o1 = integr(o2) and o2 = integr(o1) in o1

let node g(f)() = let rec x = run f x in 1
let node ff x = 0 fby x

let node main() = g ff ()
    
let hybrid f(x0, x) = o where
  rec forall i in 0 .. 4, xi in x, oi out o do
	der oi = xi init x0 done *)

