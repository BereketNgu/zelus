open Graphics

let hybrid ff(x, e) =
  match x with
  | true -> present (up(e +. 0.0)) on x | up(e) -> 2 else 0
  | false -> present up(e) -> 1 else 0

      (*
let node f1 x =
  let rec init o = x  and o = last o + 1 in o
    
let hybrid h (z) = () where
  rec t2 = 1
  and present z -> do x = last t2 + 1 done else do x = 0 done


      
let hybrid g(x) =
  let rec der m = 1.0 +. 2.0 init 0.0 
  and der z = m init 1.0 and k = z and l = up(m) in
  m

let hybrid f (z) = y where
  rec init y = 1.0
  and present z -> do y = 1.0 done
      else do der y = 1.0 done

let hybrid main (z) = y where
  rec der y = 1.0 init -1.0 reset z -> -2.0
       *)
      
(* let hybrid main () = () where
  rec t2 = 1
  and x = last t2 + 1
 *)
					
(* x : a1 | a2   t2 : a3 | a4 *)
(* x : a6 | a7   a4 < a6, a7 *)
(* a7 < a6, a2 < a1, a4 < a3 *)
					

      
(*
let hybrid i z = o where
  rec present z -> do o = last v + 1 done and init o = 1
  and v = o + 1
 *)
    
(*
let hybrid h z = c where
  rec init c = 0 and init c' = 0
  and c' = last c (* and c = last c + 1 *)

let hybrid main2 z = x where
  rec init x = true
  and automaton
    | S0 ->
        do until z on x then do x = false in S0

    *)
      
(*  c: a_c | a_lc, sans contrainte entre eux. *)
(* a_c | a_lc < b_c | b_lc ssi a_c < b_c & a_lc < b_lc *)
(*                          et a_lc < a_c *)
	    

(* c': a_c' | a_c'  ;  o : a_o | a_o *)
	    
(*
let hybrid i (k) = x where
  rec init x = 0.0
  and present k(nx) -> do x = nx done else do der x = 1.0 done
  and present | (disc(x)) -> do emit k = -1.0 done
				 *)
	    
(*
let hybrid h(z) = (x, y) where
  rec init x = 0 and init y = 0
  and match z with
      | true -> do x = last y + 1 done
      | false -> do y = last x + 1 done

let hybrid f(z) = o where
  rec present z -> do o = last x + 1 done
  and init o = 0 and init x = 0
      
let hybrid g(x) = o where
  rec o = let rec
	      present x -> do r = 0 -> last o + 1 done
	      and init r = 0 in
	  r
	    *)

								   

	    (*
let node g(x1, k) =
  let rec r1, r2 =
    let x = (print_int 0; x1 + 2) in
    let y = (print_int 1; x + 3 + r2) in
    y, (print_int 3; k) + 2 in
  r1, r2
	     *)
	    
(*
    C | H |- e: ct reads {a1,...,an}

        G(f) = forall a1,...,an:C1.ct1 -> c2   C2 | H |- e : ct1 reads R
      -------------------------------------------------------------------
	  C1, C2 | H |- f(e) : ct2 reads R

	      C | H |- e : ct reads {a1,...,an}
         ----------------------------------------------
	      C | H |- atomic e: ct reads {a1,..., an}
		*)
	
(* let node g y = z where
  rec init x = y
  and z = last x + 1 + y


let node main () =
  let o = from 1 in
   print_int o; print_newline ()
*)


(*
let node f() = o where
  rec
      automaton
      | S1 -> do o = 1 done
      | S2(x) -> do o = x -> pre o + 1 done
      end
 *)

(*
let main2 x = let z = x + 2 in z

let node count2(n, tick) = o where
  rec
    cpt = 0 -> (pre cpt + 1) mod n
  and
    o = false -> cpt = 0
       *)

(*
let node await e = o where
  automaton
  | Await -> do unless e(v) then Sustain(v)
  | Sustain(x) -> do emit o = x done
  end
 *)

(*
>>>>>>> .r2266
let atomic node draw_pendulum1 (color, x0, y0, x, y) =
  let x0 = truncate (10.0 *. x0) in
  let y0 = truncate (10.0 *. y0) in
  Graphics.set_color color

let node f x = 0 -> pre x + 1

let node double x =
  let rec x1 = f(x2 + 1) and x2 = f(x2 + x1) in
  x + x1

let node f55(x) = y where
  rec automaton
      | S1 ->
          let rec c = 0 -> pre c + 1 in
          do y = 1 -> pre y + 1 until (c = 0) then S1
      | S2(t) ->
          do y = t + 1 - x and emit m = 1
          until (y = -10) then S1
  and cpt = 0 -> pre cpt + 1

(* let node f(x) = 0 -> pre x + 1

let node g() =
  let rec x = f(y + 1) and y = f(x+2) in
  (x) *)
     *)

(*
type event = Simple | Double

let node controller (click, top) = o where
     automaton
     | Await ->
        do until click then One
     | One -> do until click then Emit(Double)
              else (counting top = 4) then Emit(Simple)
     | Emit(x) ->
         do emit o = x
         until true then Await
     end
 *)

(* let node f5(x) = y where
  rec match x with
      | true ->
          let rec c = 0 -> pre c + 1 in
          do y = 1 -> pre y + 1 done
      | false -> do y = 0 done *)


(*
  rec error = rate -. v
  and present hit(_) -> do v = 0.0 done else do der v = error done
  and present hit(_) -> do z = 0.0 done else do der z = error done
*)


(*  let hybrid blah(x) = y where
     rec init t = 0
     and automaton
     | S1 -> do der y = x init x
             until up(y) then (* do next t = 1 in *) S1
     | S2 -> do der y = x init -10.0
             until up(y) then S1
     end
     and o = t + 2
*)
(* let hybrid truncate(x) = m where
  rec
      present
      | (up(x -. float(m) -. 1.0))
      | (up(x -. float(m) +. 1.0)) -> do next m = truncate(x) done
  and init m = truncate(x) *)

(*
let hybrid main z = r where
  rec init r  = true
  and automaton
      | S0 -> do until z then do r = false in S0
      end

let hybrid h(x, k) = y where
  rec match x with
    | true -> do der y = 0.1 done
    | false -> do der y = 1.0 done
  and init y = k
*)

(*
let hybrid f(y_1, y_0) =
  let rec der y = y_1  and init y = y_0 in
  (y)
*)

(* let atomic hybrid f (z) = o where
  rec
      present z -> do o = last o +. 2.0 done
      else do der o = 1.0 done
  and init o = 2.0

let hybrid main1 () =
  let o = f (period (0.1)) in ()

let node main () = let rec o = 0 -> pre o + 1 in () *)
(*
let atomic hybrid main (z, z0) = k where
  rec match z with
      | true -> local k1 in
                do init k1 = 0.0
                and present z0 -> do k1 = last k1 done
                    else do der k1 = k1 +. 1.0 done
                and k = k1 +. 2.0 done
      | false -> local k2 in
                 do der k2 = k2 +. 3.0 init 4.0 and k = k2 done
      end
  and der r = 1.0 +. last r init 0.0 reset z0 -> 42.0

let atomic hybrid main1 z = k where
  rec match z with
      | true -> local k1, k2 in
                do der k1 = k1 +. 1.0 init 0.0
                and der k2 = k1 +. 2.0 init 0.0
                and k = k2 done
      | false -> local k3 in
                 do der k3 = 3.0 init 4.0 and k = k3 +. 2.0 done
      end


let hybrid main () =
   let der k = 0.0 init 0.0 in
   let o = main1 true +. k in
   present (period (0.1)) -> print_float o; print_newline () else ()

let node h z =
  let rec
      match z with
      | true ->
          let k = 1 + 2 in
          let r = k + 2 in
          local s in
          do s = print_int 2;2
          and o = 1 -> last o + 1 done
      | false ->
          local k, s in
          do o = 2 -> last o + 2
          and k = 1 + 2 and s = k + 1 done
      end in
  print_int 3
*)

(*
let node f x = z where
  rec match x with
      | true -> do z = 1 and m = r + 1 done
      | false -> do z = 1 and m = r + 1 done
      end
  and
    match x with
    | true -> do t = z + 1 and r = 2 done
    | false -> do t = 1 and r = 3 done
    end

(*
r: b
z: a   m: a
b < a
t: c r: c
a < c
c < b
*)
*)

(*
let node f (x,y) = (* z1, z2, *) z3, z4 where
  rec (* match () with
      | () -> do z1 = z4 + 1 and z2 = 1 done
      end
  and *) match () with
      | () -> do z3 = 2 and z4 = 2 done
      end

let node g(x) = 2 + 3
*)

(*

let hybrid main z = () where
  rec init already = false
  and automaton
      | S0 ->
          do
          until z on (not already)
            then do next already = true in S0
*)


(*let atomic hybrid f(x) = o1, o2 where
  rec o1 = period 4.5 (2.0)
  and o2 = period (3.0)
  and present x -> do next o = 1 + o done
  and init o = 0 *)

(*
let atomic hybrid f(x) = o1, y, m where
  rec der y = y init x and o1 = up(x +. 2.0)
  and der x = y +. 2.0 init 5.0
  and present o1 -> do emit m = 1 done
*)

(*
let atomic hybrid g(x) =
  let o1, y1, m1 = f(x +. 1.0) in
  let o2, y2, m2 = f(x +. 2.0) in
  y1 +. y2

let hybrid main () = ()

let atomic hybrid g(x) = o where
  rec match x with
      | true -> do o = f(x) done
      | false -> do o = 1.0 done
      end *)
(*
let atomic node g(x, y) =
  let rec next m = x and x = 2
  and z = 0 -> (pre z + 2 + k + x)
  and k = 0 -> pre z + y + ((0 + 4) fby z)
  and match x = 0 with
      | true -> local m in do m = 1 -> pre m + 2 and s = m + 2 done
      | false -> do s = 1 -> pre s + 2 done
      end in
  m, k, z, s
*)

(*
let atomic hybrid g(x, y) = z, k where
  rec k = 1.0 init 0.0
  and  present x -> do next z = z +. 1.0 done
       else do der z = z +. 1.0 done
  and init z = 0.0
*)

(*
let atomic node g(x,y) = m, z, k where
rec k = 1.0 +. m init 0.0
  and present x -> do next z = z +. 1.0 done
      else do done
  and init z = 0.0
  and present y -> do m = 1.0 fby m +. 2.0 done
      else do m = 2.0 -> pre m -. 1.0 done
  and init m = 4.0
*)
(*
let atomic hybrid f(x,y) = z where
  rec der k = 1.0 init 0.0 reset x -> 2.0
  and present x -> do z = 1.0 done
      else do der z = 2.0 done
  and init z = 0.0
*)

(*
let atomic hybrid f(x, y) = z where
  present | x() -> do next z = 1.0 done
          | y() -> do done
  else do der z = 2.0 done
  and init z = 0.0
*)

(*
let atomic node g(x) = z,t where
  rec z = 0 -> pre z + x + pre y
  and y = z + 1 -> pre x
  and match x >= 0 with
      | true -> do t = 0 -> pre t + 1 done
      | false -> do t = 2 -> pre t - 1 done
      end
*)

(*
let node g(x) = y, k, m where rec
  automaton
  | S1 -> do y = 2 and m = 3 until x() then S1
  | S2 -> do y = 1 and m = 4 until k(w) then S1
  end
  and present x(_) -> do emit k = 0 done
*)

 (*let hybrid f1 x =
  let rec
      automaton
      | S1 -> do der y = 1.0 until x then S2
      | S2 -> do done
      end
  and init y = 0.0 in
  y
*)

(*
let node h () = x where
  rec (x, _) = (1, 2) init (1, 2)
*)

(*
let node f(x) = o where
  rec init o = 1
  and reset
        match x with
        | true -> local o1 in
                  do o1 = 0 -> pre o1 + 1 and o = 1 + o1 done
        | false -> do o = 1 -> pre o done
        end
      every (last o) = 4
*)

(*
let node g(x) = o where
  rec o = 0 fby y and y = 2 fby o

let hybrid h(x) = o where
  rec o = present x -> last o + 1 init 0
*)

(*
let hybrid h(x) =
  let der z = 1.0 init 0.0 in
  let o = present x -> (z +. 2.0) else 0.0 in
  o +. 2.0
*)

(*
let node h(x) =
  let rec init y = 0 and init z = 2 and init k = 2 and init l = 2
  and present
      | true -> do y = 1 and z = l done
      end
  and present
      | true -> do k = y and l = 2 done
      end in
  y, z
*)

(*
let node g(x,z) = y, 1 where
 rec y = x + 1 and x = 0 -> pre y + 1
*)

(*
let node h() = x where
  rec automaton
      | Init -> do x = 0 until (x >= 10) then Up done
      | Up -> do x = 0 until (x >= 20) then do emit y = x in Init done

let node f() = (x, y) where
  rec match true with
      | true -> do x = last y + 1 done
      | false -> do y = last x + 1 done
  and init x = 0
  and init y = 0
  and z = x + 1

let node g() = x where
  rec automaton
      | Init(x0) -> do x = x0 -> pre x + 1 until (x >= 10) then Up(x) done
      | Up(x0) -> do x = x0 -> pre x + 2 until (x >= 20) then Down done
      | Down -> do x = 0 then Init(0) done
      init Init(-1)

let node main() =
  let x = g() in
  print_int x;
  print_newline ()
*)

(*
let hybrid f () = y where
  rec init y = 0.0
  and automaton
      | S1 ->
          local z in
          do der y = 1.0 reset z -> 10.0
          and z = up(y -. 10.0)
          until z then S2 done
      | S2 ->
          local z, y' in
          do y' = 1.0 and der y = y' and z = up(y -. 10.0)
          until z then S1 done

*)

(*
let hybrid f z = o where
  rec
      match z with
      | true -> present k -> do o = 1 done
      | false -> present r -> do o = 2 done
      end
*)

(* let hybrid g k =
  let m = f k in
  let v = exceed 1.0 in
  m +. 2.0 *)

(*
let node h x = x + 1

let hybrid g x = o where
  rec o = present x -> h 1 init 2

let hybrid f x = o where
  rec automaton
      | S1 ->
          do der o = 1.0 until x then do o = 2.0 in S1 done
  and init o = 0.0
*)

(*
let hybrid ff z = o where rec der o = 1.0 init 0.0 reset z -> 2.0

let hybrid g z = x where
  rec init x = 1.0
  and match z with
      | true -> local y in do der y = 2.0 init 0.0 done
      | false -> local z in do der z = 3.0 and init z = 2.3 done

let node h () = () where
  rec x = 1 -> last x + 1

let hybrid main () = () where
  rec match true with
      | true -> do present (period 1.0 (2.0)) -> do done done
      | false -> do done

let node i(x) = () where
  rec
      match x with
      | true -> local m, last_m in
                do m = 1 -> last_m and last_m = pre(m) and r = m done
      | false -> do r = 2 done

let hybrid f1 (z, v) = c where
  rec der c = 1.0 init -. v reset z -> 2.0

let hybrid f2 (z, v) = c where
  rec present (z) -> do c = 2.0 done else do der c = 1.0 done
  and init c = -. v

let hybrid main2 () =
  let rec z = period(1.0)
      and c1 = f2(z, 1.0)
      and c2 = f2(z, 1.0) in
  c1 = c2

let hybrid f3(z) = o where
  rec present
         z -> do o = 1 done else do o = 2 done
*)
