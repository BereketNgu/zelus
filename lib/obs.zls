let q_true = infinity
let q_false = neg_infinity

let q_gt (p1, p2) = p1 -. p2
let q_ge (p1, p2) = p1 -. p2
let q_lt (p1, p2) = p2 -. p1
let q_le (p1, p2) = p2 -. p1

let q_not p = -. p
let q_or (p1, p2) = max p1 p2
let q_and (p1, p2) = min p1 p2

let q_if (cond, p1, p2) = q_or (q_and (cond, p1), q_and (q_not cond, p2))
let implies (a, b) = q_or(q_not a, b)

node q_up p = p -> q_and (q_lt (pre p, 0.), q_gt (p, 0.))
node b_up p = p -> (not (pre p) && p)

node counter t (tstep, start) =
    let rec cpt = if start then t else -1. -> (pre cpt -. tstep) in cpt

node once p = res where rec res = p -> q_or (pre res, p)
node once_timed t (tstep, p) =
    let cpt = counter t (tstep, true fby false) in
    implies (q_lt (cpt, 0.), once p)

node always p = res where rec res = p -> q_and (pre res, p)
node always_timed t (tstep, p) =
    let cpt = counter t (tstep, true fby false) in
    implies (q_gt (cpt, 0.), always p)

(*
node always p = q_not (once (q_not p))
node always_timed t (tstep, p) = q_not (once_timed t (tstep, q_not p))
*)

node never p = q_not (once p)
node never_timed t (tstep, p) =
    let cpt = counter t (tstep, true fby false) in
    implies(p, q_gt(cpt, 0.))

(*
node never p = always (q_not p)
node never_timed t (tstep, p) = always_timed t (tstep, q_not p)
*)

node since (x, y) =
    let rec xsincey = q_if (y, x, q_true -> q_or (x, pre xsincey)) in
    xsincey

(* TODO: vérifier ça *)
node since_timed t (tstep, x, y) =
    let cpt = counter t (tstep, b_up (y >= 0.)) in
    implies(q_le (cpt, 0.), since (x, y))

node watchdog delay (tstep, start, obs) =
    let cpt = counter delay (tstep, start) in
    let seenObs = reset once obs every start in
    q_or (q_ge (cpt, 0.), seenObs)

(* B a été vrai au moins une fois t secondes après la dernières fois où A a été
   vrai

   Note: si A n'a jamais été vrai, le résultat sera negatif

   Note: différent de "chaque ocurence de a est suivie d'une occurence de b
         après moins de t secondes" *)
node onceBfromA delay (tstep, a, b) =
    watchdog delay (tstep, a, b)

(* depuis le premier moment où a a été vrai et le dernier moment où c a été vrai,
   b a été vrai au moins une fois *)
node onceBfromfirstAtoC(a, b, c) =
    implies(c, q_or (never a, since(b, a)))

node neverBfromAtoC (a, b, c) = implies (c, q_not (since (b, a)))

(* Pattern templates *)

(* it is never the case that p holds *)
node absence p = never p

(* during the first T seconds, it is never the case that p holds *)
node absence_timed t (tstep, p) = never_timed t (tstep, p)

(* it is always the case that once p becomes satisfied, it holds for at
   least T seconds *)
node minimum_duration t (tstep, p) =
    let cpt = counter t (tstep, b_up (p >= 0.)) in
    implies (q_not p, q_lt(cpt, 0.))

(* it is always the case that once p becomes satisfied, it holds for at
   most T seconds *)
node maximum_duration t (tstep, p) =
    let cpt = counter t (tstep, b_up (p >= 0.)) in
    implies (p, q_ge(cpt, 0.))

(* it is always the case that p holds at least every T seconds *)
node bounded_recurrence t (tstep, p) =
    let cpt = counter t (tstep, true -> b_up (p >= 0.)) in
    q_ge (cpt, 0.)

(* it is always the case that if p holds, then s holds after at
   most T seconds *)
node bounded_response t (tstep, p, s) =
    q_or (never p, onceBfromA t (tstep, b_up (p >= 0.), s))

(* it is always the case that if p holds then s holds for at least T seconds *)
node bounded_invariance t (tstep, p, s) =
    let cpt = counter t (tstep, b_up (p >= 0. && s >= 0.)) in
    q_or (s, (q_le (cpt, 0.)))
