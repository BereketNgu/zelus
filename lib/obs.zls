type state = NotYet | Done

node p_select_apply(n)(p)(l) = run p (Basics.list_nth l n)
node select_apply(n)(f)(t, l) = run f (t, Basics.list_nth l n)

node string_of_state st = match st with | NotYet -> "Not yet" | Done -> "Done"
node float_of_state st = match st with | NotYet -> 0. | Done -> 1.

(* PREDICATES = tstep * float -> float *)

node p_lt r x = r -. x
node p_gt r x = x -. r
node p_le r x = r -. x
node p_ge r x = x -. r

node p_not p     x = -. (run p x)
node p_and p1 p2 x = min (run p1 x) (run p2 x)
node p_or  p1 p2 x = max (run p1 x) (run p2 x)

(* i is a float with integer values, i = r <=> i > r - 0.5 && i < r + 0.5 *)
node p_eqi r i = min (i -. r +. 0.5) (r +. 0.5 -. i)

(* FORMULAS : tstep * args -> bool *)

(*
    Next(r) ≡ ♦_[0,r]
*)
node d_next r (tstep, p) = v, state where
    rec t = 0. fby (t +. tstep)
    and automaton
        | I ->
            do v = p -> max (pre v) p
            and state = NotYet
            until (p > 0.) on (t <= r) then Sink(v)
            else (t > r) then Sink(v)
        | Sink(f) -> do v = f and state = Done done

node d_next_ub (tstep, p) = d_next infinity (tstep, p) (* WARNING *)

(*
    AlwaysL(r) ≡ □_[0,r]
*)
node d_always_l r (tstep, p) = v, state where
    rec t = 0. fby (t +. tstep)
    and automaton
    | I ->
        do v = p -> min (pre v) p
        and state = NotYet
        until (t > r) then Sink(v)
        else (p < 0.) on (t <= r) then Sink(v)
    | Sink(f) -> do v = f and state = Done done

node d_always (tstep, p) = d_always_l infinity (tstep, p)

(*
    AlwaysR(r) ≡ □_[r,+∞[
*)
node d_always_r r (tstep, p) = v, state where
    rec t = 0. fby (t +. tstep)
    and automaton
    | I ->
        do v = infinity
        and state = NotYet
        until (t >= r) on (p > 0.) then Main
        else (t >= r) on (p < 0.) then Sink(p)
    | Main ->
        do v = p -> min (pre v) p
        and state = NotYet
        until (p < 0.) then Sink(v)
    | Sink(f) -> do v = f and state = Done done

node d_pand  phi (tstep, (p, x)) =
    let init p_init = p in
    let v, state = run phi (tstep, x) in
    if p_init < 0. then p_init, Done else (min p_init v), state
    (* automaton
    | I ->
        do v = p
        until (true fby false) on (not p) then Sink(p)
        else (true fby false) on (p) then Main
    | Main -> do v = run phi (tstep, x) done
    | Sink(f) -> do v = f done *)

node d_por phi (tstep, (p, x)) =
    let init p_init = p in
    let v, state = run phi (tstep, x) in
    if p_init > 0. then p_init, Done else (max p_init v), state

(*
    And(phi1, phi2)(x) ≡ phi1(x) ∧ phi2(x)
*)
node d_and phi1 phi2 (tstep, x) =
    let v1, state1 = run phi1 (tstep, x)
    and v2, state2 = run phi2 (tstep, x) in
    min v1 v2,
    automaton
    | I ->
        do NotYet until (state1 = Done) on (v1 < 0.)
                      | (state2 = Done) on (v2 < 0.) then Sink
        else (state2 = Done) on (v2 > 0.) then S1
        else (state1 = Done) on (v1 > 0.) then S2
    | S1 -> do NotYet until (state1 = Done) then Sink
    | S2 -> do NotYet until (state2 = Done) then Sink
    | Sink -> do Done done

(*
    Or(phi1, phi2)(x) ≡ phi1(x) ∨ phi2(x)
*)
node d_or phi1 phi2 (tstep, x) =
    let v1, state1 = run phi1 (tstep, x)
    and v2, state2 = run phi2 (tstep, x) in
    max v1 v2,
    automaton
    | I ->
        do NotYet until (state1 = Done) on (v1 > 0.)
                      | (state2 = Done) on (v2 > 0.) then Sink
        else (state2 = Done) on (v2 < 0.) then S1
        else (state1 = Done) on (v1 < 0.) then S2
    | S1 -> do NotYet until (state1 = Done) then Sink
    | S2 -> do NotYet until (state2 = Done) then Sink
    | Sink -> do Done done

(*
    TriggerL(r)(phi)(p, x) ≡ □_[0,r](p ⇒ phi)
*)
node d_trigger_l r phi (tstep, (p, x)) = v, state where
    rec t = 0. fby (t +. tstep)
    and automaton
    | I ->
        do v = (-. p) -> min (pre v) (-. p)
        and state = NotYet
        until (p > 0.) on (t <= r) then S
        else (t > r) then Sink(v)
    | S ->
        let v', state' = run phi (tstep, x) in
        do v = min p v' and state = NotYet
        until (state' = Done) on (t < r) then I
        else (state' = Done) on (t >= r) then Sink(v)
        else (state' = Done) then Sink(v)
    | Sink(f) -> do v = f and state = Done done

node d_trigger phi (tstep, (p, x)) = d_trigger_l infinity phi (tstep, (p, x))

(*
    TriggerR(r)(phi)(p, x) ≡ □_[r,+∞[(p ⇒ phi)
*)
node d_trigger_r r phi (tstep, (p, x)) = v, state where
    rec t = 0. fby (t +. tstep)
    and automaton
    | I ->
        do v = infinity and state = NotYet
        until (p > 0.) on (t >= r) then S
    | S ->
        let v', state' = run phi (tstep, x) in
        do v = v' and state = NotYet
        until (state' = Done) on (v > 0.) then I
        else (state' = Done) on (v < 0.) then Sink(v)
    | Sink(f) -> do v = f and state = Done done

(*
    Always_or_l(r)(phi1, phi2)(x) ≡ □_[0,r](phi1 ∨ phi2)
*)
node d_always_l_or r phi1 phi2 (tstep, x) = v, state where
    rec t = 0. fby (t +. tstep)
    and automaton
    | I ->
        let v', state' = run (d_or phi1 phi2) (tstep, x) in
        do v = v' and state = NotYet
        until (state' = Done) on (v' > 0.) on (t <= r) then I
        else (state' = Done) on (v' > 0.) on (t > r) then Sink(v)
        else (state' = Done) on (v' < 0.) then Sink(v)
    | Sink(f) -> do v = f and state = Done done

(*
    Always_or_r(r)(phi1, phi2)(x) ≡ □_[r, +∞[(phi1 ∨ phi2)
*)

node d_always_r_or r phi1 phi2 (tstep, x) = v, state where
    rec t = 0. fby (t +. tstep)
    and automaton
    | I ->
        do v = infinity and state = NotYet
        until (t > r) then S
    | S ->
        let v', state' = run (d_or phi1 phi2) (tstep, x) in
        do v = v' and state = NotYet
        until (state' = Done) on (v > 0.) then S
        else (state' = Done) on (v < 0.) then Sink(v)
    | Sink(f) -> do v = f and state = Done done
