(* TRACE COMBINATORS *)

node t_fby(t1, t2)(e, (tstep, prev)) = t where
  rec init last_val = prev
  and automaton
  | NotSeenE -> do t = run t1 (tstep, last last_val)
                until e then
                do last_val = t in SeenE
  | SeenE    -> do t = run t2 (tstep, last last_val) done

node t_loop(t_in)(e, (tstep, prev)) = t_res where
  rec init last_val = prev
  and automaton
  | SeenE -> do t_res = run t_in (tstep, last last_val)
             until e then
             do last_val = t_res in SeenE

node t_switch(t1, t2)(e, (tstep, prev)) =
    if e then (run t1 (tstep, prev)) else (run t2 (tstep, prev))

node t_rand_switch(p)(t1, t2)(tstep, prev) =
  let init b = Random.float(1.) < p in
  t_switch(t1, t2)(b, (tstep, prev))

(* TRACE GENERATION *)

let pick_float(i1, i2) = Random.float(i2 -. i1) +. i1

node const(i1, i2)(_, _) = res where
  init res = pick_float(i1, i2)

node flat(_, prev) = res where
  init res = prev

node linear(i1, i2)(tstep, prev) = res where
  rec init slope = pick_float(i1, i2)
  and res = prev fby (res +. slope *. tstep)

node bounded_affine(i1, i2)(slope_mag)(tstep, prev) = res where
  rec reset slope =
    (if res > i2 then pick_float(-.slope_mag, 0.)
     else if res < i1 then pick_float(0., slope_mag)
     else pick_float(-.slope_mag, slope_mag))
    fby slope
    every (res > i2 || res < i1)
  and res = prev fby (res +. slope *. tstep)

(* EVENT FUNCTIONS *)

node clock(freq)(tstep) =
    automaton
        | I ->
            let rec t = 0. fby (t +. tstep) in
            do true fby false
            until (t >= freq) then I


(* node no_evt(_) = e where present up(1.) -> do emit e = () done

node horizon(h)(_) = e where
  rec der t = 1. init 0.
  and present up(t -. h) -> do emit e = () done

node rand_horizon(h1, h2)(_) = e where
  rec der t = 1. init 0.
  and init h = pick_float(h1, h2)
  and present up(t -. h) -> do emit e = () done

node sig_of_zero(z) = e where
  present z -> do emit e = () done

node val_gt_0(x) = e where
  present up(x) -> do emit e = () done
node val_gt(f)(x) = val_gt_0(x -. f)
node val_lt(f)(x) = val_gt_0(f -. x)

node e_and(e1, e2)(f1, f2) = e where
  rec e1_listener = (run e1 f1)
  and e2_listener = (run e2 f2)
  and init got_1 = false and init got_2 = false and init is_done = false
  and present
  | e1_listener() on (got_2 && (not (is_done)))
  | e2_listener() on (got_1 && (not (is_done))) ->
    do emit e = () and next is_done = true done
  | e1_listener() on (not (got_2)) -> do next got_1 = true done
  | e2_listener() on (not (got_1)) -> do next got_2 = true done

node e_or(e1, e2)(f1, f2) = e where
  rec e1_listener = (run e1 f1)
  and e2_listener = (run e2 f2)
  and init is_done = false
  and present
  | e1_listener() on (not (last is_done))
  | e2_listener() on (not (last is_done)) ->
  do emit e = () and is_done = true done *)
