open Scope

hybrid test_adc() =
    let der t = 1. init 0. in
    let vt = 300. +. 250. *. sin (2. *. t) in
    let alt = 2500. +. 2000. *. cos (t /. 2.) in
    let amach, qbar = Utils.adc(vt, alt) in
    present (period(0.1)) ->
        let s1 = scope (0., 550., ("vt", linear, vt)) in
        let s2 = scope (0., 4500., ("alt", linear, alt)) in
        let s3 = scope (0., 1., ("amach", linear, amach)) in
        let s4 = scope (0., 500., ("qbar", linear, qbar)) in
        window4("Test adc", 50., t, s1, s2, s3, s4)
    else ()

hybrid test_dampp() =
    let der t = 1. init 0. in
    let alpha = 0.392 +. 0.3 *. cos(t) in
    let d0, d1, d2, d3, d4, d5, d6, d7, d8 = Utils.dampp(alpha) in
    present (period(0.1)) ->
        let s1  = scope (  0.000,   0.700, ("alpha", linear, alpha)) in
        let s2  = scope (  0.300,   0.450, ("d0", linear, d0)) in
        let s3  = scope (  0.860,   0.895, ("d1", linear, d1)) in
        let s4  = scope (- 0.200, - 0.140, ("d2", linear, d2)) in
        let s5  = scope (-29.300, -28.800, ("d3", linear, d3)) in
        let s6  = scope (  0.060,   0.070, ("d4", linear, d4)) in
        let s7  = scope (- 0.450, - 0.440, ("d5", linear, d5)) in
        let s8  = scope (- 5.240, - 5.230, ("d6", linear, d6)) in
        let s9  = scope (- 0.380, - 0.378, ("d7", linear, d7)) in
        let s10 = scope (  0.040,   0.055, ("d8", linear, d8)) in
        windown("Test dampp", 50., t, [s1; s2; s3; s4; s5; s6; s7; s8; s9; s10])
    else ()

hybrid test_thrust() =
    let der t = 1. init 0. in
    let power = 9. in
    let alt = 2500. +. 2000. *. cos (t /. 2.) in
    let rmach = 0.5 +. 0.3 *. sin (t /. 4.) in
    let thrust = Utils.thrust(power, alt, rmach) in
    present (period(0.1)) ->
        let s1 = scope (0., 10., ("power", linear, power)) in
        let s2 = scope (0., 4500., ("alt", linear, alt)) in
        let s3 = scope (0., 1., ("rmach", linear, rmach)) in
        let s4 = scope (0., 3000., ("thrust(power, alt, rmach)", linear, thrust)) in
        window4("Test thrust", 50., t, s1, s2, s3, s4)
    else ()

hybrid test_tgear() =
    let der t = 1. init 0. in
    let thtl = 0.5 +. 0.5 *. cos(t /. 2.) in
    let tgear = Utils.tgear thtl in
    present (period(0.1)) ->
        let s1 = scope (0., 1., ("thtl", linear, thtl)) in
        let s2 = scope (0., 100., ("tgear", linear, tgear)) in
        window2("Test tgear", 50., t, s1, s2)
    else ()

let static dtor = 1.745329e-2 (* deg to rad coefficient *)
let rand_float low high = Random.float (high -. low) +. low

node test_morelli() =
    let rec step = 0 fby (step + 1) in
    let alpha = rand_float (-5.) 0.5 in
    let beta = rand_float (-1.) 1. in
    let el = rand_float (-25.) 25. *. dtor in
    let ail = rand_float (-21.5) 21.5 *. dtor in
    let rdr = rand_float (-30.) 30. *. dtor in
    let p = rand_float (-100.) 250. in
    let q = rand_float (-7.) 1. in
    let r = rand_float (-8.) 6. in
    let vt = rand_float 0. 5000. in
    let cbar = 11.32 in
    let b = 30. in
    let xcg = 0.35 in
    let xcgr = 0.35 in

    let cxt, cyt, czt, clt, cmt, cnt =
        Utils.morellif16
            (alpha, beta, el, ail, rdr, p, q, r, cbar, b, vt, xcg, xcgr)
    in

    let cxtP, cytP, cztP, cltP, cmtP, cntP =
        Mlutils.run_Morelli alpha beta el ail rdr p q r cbar b vt xcg xcgr
    in

    Mlutils.print_results step
        (alpha, beta, el, ail, rdr, p, q, r, cbar, b, vt, xcg, xcgr)
        (cxt, cyt, czt, clt, cmt, cnt)
        (cxtP, cytP, cztP, cltP, cmtP, cntP)

hybrid test_pdot() =
    let der t = 1. init 0. in
    let p1 = 50. +. 50. *. cos(t /. 3.) in
    let p3 = 50. +. 50. *. cos(t /. 7.) in
    let pdot = Utils.pdot (p3, p1) in
    present (period(0.1)) ->
        let s1 = scope (0., 100., ("p1", linear, p1)) in
        let s2 = scope (0., 100., ("p3", linear, p3)) in
        let s3 = scope (-300., 300., ("pdot", linear, pdot)) in
        window3("Test pdot", 50., t, s1, s2, s3)
    else ()
