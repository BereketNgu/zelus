open Misc

(*** Modeling Quasi-periodic Architecturea ***)

(** Bounds of Definition 1 **)
let t_min = 300.0
let t_max = 350.0
let tau_min = 10.0
let tau_max = 50.0


(** Quasi-periodic clocks **)
let hybrid metro (t_min, t_max) = c where
  rec der t = 1.0 init -. arbitrary (t_min, t_max)
        reset up(last t) -> -. arbitrary (t_min, t_max)
  and present up(t) -> do emit c = () done


(** Delayed clock. Model transmission delay **)
let hybrid delay(c, tau_min, tau_max) = dc where
  rec der t = 1.0 init 0.0
        reset c() ->  -. arbitrary (tau_min, tau_max)
  and present up(t) -> do emit dc = () done



(*** General Framework ***)

(** Memory. Maintain the last received value on a signal *)
let node mem (i, default) = m where
  rec init m = default
  and present i(v) -> do m = v done


(** Modeling nodes **)
(* Require instanciations of nodes machine and ltta_controller *)
(*
let node ltta_node(i, default) = o where
  rec m = mem(om, default)
  and (o, im) = ltta_controller(i, m)
  and present im(v) -> do emit om = machine(v) done
*)

(** Modeling links **)
let node channel (dc, i) = o where
  rec init mem = empty()
  and present
      | dc() on (not (is_empty (last mem))) & i(v)  ->
          do emit o = front (last mem)
          and mem = enqueue(dequeue(last mem), v) done
      | dc() on (not (is_empty (last mem))) ->
          do emit o = front (last mem)
          and mem = dequeue (last mem) done
      | i(v) ->
          do mem = enqueue (last mem, v) done


let node link(dc, i, default) = o where
  rec s = channel(dc, i)
  and o = mem(s, default)


(** Freshness of value **)
type 'a msg = {data : 'a; alt : bool}

let node alternate i = o where
  rec present i(v) -> local flag in
        do flag = true -> not (pre flag)
        and emit o = {data = v; alt = flag} done


let node fresh (i, r) = o where
  rec init m = false
  and present r(_) -> do m = i.alt done
  and o = (i.alt <> last m)

let data v = v.data

(** LTTA links **)
let node ltta_link (dc, i, default) = m where
  rec s = channel (dc, i)
  and m = mem (alternate s, {data = default; alt = false})

(*** The LTTA Protocols ***)

(** Back-Pressure LTTA **)
let node bp_controller (i, ra, m) = (o, a, im) where
  rec automaton
      | Wait ->
          do (* skip *)
          unless all_inputs_fresh then
            do emit im = data(i) and emit a = () in Ready
      | Ready ->
          do (* skip *)
          unless all_acks_fresh then
            do emit o = m in Wait

  and all_inputs_fresh = fresh(i, im)
  and all_acks_fresh = fresh(ra, o)


(** Time-Based LTTA **)
(* Constants of thm 6 *)
let p =
  int_of_float (
  floor ((2. *. tau_max +. t_max) /.
        t_min) +. 1.)

let q =
  int_of_float (
  floor ((tau_max  +. (1. +. float (p)) *. t_max) /.
         t_min -. float (p)) +. 1.)

let node tb_controller (i, ro, m) = (o, im) where
  rec init n = 1
  and automaton
      | Wait ->
          do n = p -> (pre n - 1)
          unless (last n = 1) then
            do emit im = data(i) in Ready
      | Ready ->
          do n = q -> (pre n - 1)
          unless ((last n = 1) or preempted) then
            do emit o = m in Wait

  and preempted = fresh(i, im) or fresh(ro, im)



(*** Appendix ***)

(** Modeling Transmission Delay **)
let hybrid delay2(c, tau_min, tau_max, eps) = dc where
  rec init q = empty()
  and init t = 0.0
  and init trans = false
  and present
      | c() & up(last t) ->
          local tau, d in
          do if is_empty(last q) then do t = -. tau done
             else do q = enqueue(dequeue(last q), d)
                  and t = -. front(last q) done
          and tau = arbitrary(tau_min, tau_max)
          and d = max(eps, tau -. sum(last q) +. last t)
          and emit dc = () done
      | up(last t) ->
          do if is_empty(last q) then do trans = false done
             else do t = -. front(last q) and q = dequeue(last q) done
          and emit dc = () done
      | c() ->
          local tau, d in
          do if last trans then do  q = enqueue(last q, max(d, eps)) done
              else do t = -. tau and trans = true done
          and tau = arbitrary(tau_min, tau_max)
          and d = tau -. sum(last q) +. last t done
   else do der t = 1.0 done


(** Broadcast Communication **)
let node rb_controller (i, m) = (o, im) where
  rec automaton
      | Wait ->
          do (* skip *)
          unless all_fresh_inputs then
            do emit im = data(i) and emit o = m in Wait

  and all_fresh_inputs = fresh(i, im)



(*** A small example ***)

(** The embedded application **)
let node machine1 () = n where
  rec n = 1 -> (pre n + 2)

let node machine2 () = m where
  rec m = 0 -> (pre m + 2)

(** LTTA nodes **)
let node n1(i, ro) = o where
  rec m = mem (om, 0)
  and (o, im) = tb_controller(i, ro, m)
  and present im(_) -> do emit om = machine1() done

let node n2(i, ro) = o where
  rec m = mem(om, 0)
  and (o, im) = tb_controller(i, ro, m)
  and present im(_) -> do emit om = machine2() done

(** Dummy ltta_link for nodes with no inputs **)
let source () = {data = 0; alt = false}

(** Pluging two nodes with links to form an example **)

(* Note the activations of node on clock c1 and c2, *)
(* and the links on their delayed version dc1 and dc2. *)
(* The output if the content of the links at each step. *)
let node example (c1, dc1, c2, dc2) = (o1, o2) where
   rec present c1() -> do n = n1(l0, l0) done
   and present c2() -> do m = n2(l0, l0) done
   and l0 = source()
   and l1 = ltta_link(dc1, n, 0)
   and l2 = ltta_link(dc2, m, 0)
   and o1 = l1.data
   and o2 = l2.data


(** Link with the timing constraints of the application : Simulation **)
let hybrid main () = () where

  (* Architecture constraints *)
  rec c1 = metro(t_min, t_max)
  and dc1 = delay(c1, tau_min, tau_max)
  and c2 = metro(t_min, t_max)
  and dc2 = delay(c2, tau_min, tau_max)

  (* Global clock *)
  and present c1() | dc1() | c2() | dc2() -> do emit g = () done

  and present g() -> local o1, o2 in
        (* Run the example model *)
        do (o1,o2) = example(c1, dc1, c2, dc2)
        and _ = print (o1, o2) done
