type loc = NoLoc | Loc1 | Loc2 | Loc3

let static pi    = 3.14159265359
let static twopi = 6.28318530718

let static alpha   =      0.030
let static ks      =  10000.000
let static tstep   =      0.005

let float_to_scope prefix suffix (i, f) =
    (prefix ^ (string_of_int i) ^ suffix, Scope.linear, f)

let array_to_scope_list prefix suffix a =
    Zlarray.mapi (float_to_scope prefix suffix) a

discrete mod_twopi f = mod_float f twopi

hybrid is_lt (x, y) =
    present
        | up(y -. x)
        | (disc(x)) on (x < y)
        | (disc(y)) on (x < y) -> ()

hybrid is_le (x, y) =
    present
        | up(y -. x)
        | (disc(x)) on (x <= y)
        | (disc(y)) on (x <= y) -> ()

hybrid is_gt (x, y) =
    present
        | up(x -. y)
        | (disc(x)) on (x > y)
        | (disc(y)) on (x > y) -> ()

hybrid is_ge (x, y) =
    present
        | up(x -. y)
        | (disc(x)) on (x >= y)
        | (disc(y)) on (x >= y) -> ()

hybrid loc_c x1 =
    automaton
        | Init ->
            do NoLoc
            unless (init) on (x1 >= alpha) then Loc1
            else   (init) on (x1 < alpha && x1 > -. alpha) then Loc2
            else   (init) on (x1 <= -. alpha) then Loc3
        | Loc1 ->
            do Loc1
            unless (is_lt(x1, alpha))() on (x1 > -. alpha) then Loc2
            else   (is_lt(x1, alpha))() on (x1 <= -. alpha) then Loc3
        | Loc2 ->
            do Loc2
            unless (is_ge(x1, alpha))() then Loc1
            else   (is_le(x1, -. alpha))() then Loc3
        | Loc3 ->
            do Loc3
            unless (is_gt(x1, -. alpha))() on (x1 >= alpha) then Loc3
            else   (is_gt(x1, -. alpha))() on (x1 < alpha) then Loc2

node loc_d x1 =
    if x1 >= alpha then Loc1
    else if x1 <= -. alpha then Loc3
    else Loc2

let string_of_loc l =
    match l with
    | NoLoc -> "NoLoc"
    | Loc1 -> "Loc1"
    | Loc2 -> "Loc2"
    | Loc3 -> "Loc3"

let radps2rpm radps = radps /. twopi *. 3600.

open Scope
open Zlarray
open Powertrain

(*
    The set X0 of initial states is defined by
    X0 = { c + αg | α ∈ [−1,1] }
    c= [ -0.0432,  -11,  0, 30,  0, 30, 360, -0.0013, 30, ..., -0.0013, 30]
    g= [  0.0056, 4.67,  0, 10,  0, 10, 120,  0.0006, 10, ...,  0.0006, 10]
*)

let initial_state alpha =
    {
        x1  = -0.0432 +. alpha *. 0.0056;
        x2  =   -11.0 +. alpha *. 4.67;
        x3  = 0.0;
        x4  =    30.0 +. alpha *. 10.0;
        x5  =   360.0 +. alpha *. 120.0;
        x6  = -0.0013 +. alpha *. 0.0006;
        x7  =    30.0 +. alpha *. 10.0;
        x8  = -0.0013 +. alpha *. 0.0006;
        x9  =    30.0 +. alpha *. 10.0;
        x10 = -0.0013 +. alpha *. 0.0006;
        x11 =    30.0 +. alpha *. 10.0;
        x12 = -0.0013 +. alpha *. 0.0006;
        x13 =    30.0 +. alpha *. 10.0;
    }

node plot title (t, u, tm, ts, theta_m, theta_s, theta_l, theta_1, theta_m_der,
        theta_s_der, theta_l_der, theta_1_der, theta_ders) =
    let s1 = scope (-5.,   5.,
        ("command u = Θ''<sub>ref</sub> [m.s-2]", linear, u)) in
    let s2 = scope ( 0., 100.,
        ("motor torque T<sub>m</sub> [Nm]", linear, tm)) in
    let s3 = scope ( 0., 100.,
        ("T<sub>s</sub> [Nm]", linear, ts)) in
    let s4 = scope ( 0., 100.,
        ("engine ω<sub>m</sub> [m.s-1]", linear, radps2rpm theta_m_der)) in
    let s5 = scope ( 0., 100.,
        ("Θ'<sub>s</sub> [rpm]", linear, radps2rpm theta_s_der)) in
    let s6 = scope3( -1., 1.,
        ("Θ<sub>s</sub> - Θ<sub>1</sub> [rad]", linear, theta_s -. theta_1),
        ("alpha", linear, alpha),
        ("- alpha", linear, -.alpha)) in
    let s7 = scope ( 0., 100.,
        ("load speed Θ'<sub>l</sub> [rpm]", linear, radps2rpm theta_l_der)) in
    let s8 = scope ( 0., 100.,
        ("Θ'<sub>1</sub> [rpm]", linear, radps2rpm theta_1_der)) in
    windown("Powertrain - " ^ title, 2., t, [s1; s4; s7; s8])
    (* windown("Powertrain - " ^ title, 2., t, [s1; s2; s3; s4; s5; s6; s7; s8]) *)

hybrid inputc t =
    automaton
        | S1 -> do -5. unless up(t -. 0.2) then S2
        | S2 -> do  5. done

node inputd t =
    if t < 0.2 then -5. else if t < 2.0 then 5. else 0.

let hybrid mainc () =
    let rec der t = 1. init 0.
    and cur_loc = loc_c (theta_s -. theta_1)
    and ks' = match cur_loc with Loc2 -> 0. | _ -> ks
    and alpha' = match cur_loc with Loc3 -> -. alpha | _ -> alpha
    and u = inputc t
    and (tm, ts, theta_m, theta_s, theta_l, theta_1, theta_m_der, theta_s_der,
            theta_l_der, theta_1_der, theta_ders) =
            powertrainc (initial_state 0., ks', alpha', u)
    in
    present (period(0.0005)) ->
        plot "continuous"
             (t, u, tm, ts, theta_m, theta_s, theta_l, theta_1, theta_m_der,
                 theta_s_der, theta_l_der, theta_1_der, theta_ders)
    else ()

let static h0      = 0.1
let static maxstep = 1.0
let static eps     = 1.0e-4

let node maind () =
    let rec cur_loc = loc_d (theta_s -. theta_1)
    and ks' = match cur_loc with Loc2 -> 0. | _ -> ks
    and alpha' = match cur_loc with Loc3 -> -. alpha | _ -> alpha
    and u = inputd t
    and (t, tm, ts, theta_m, theta_s, theta_l, theta_1, theta_m_der, theta_s_der,
            theta_l_der, theta_1_der, theta_ders) =
            powertraind h0 maxstep eps (initial_state 0., ks', alpha', u)
    in
    plot "discrete"
         (t, u, tm, ts, theta_m, theta_s, theta_l, theta_1, theta_m_der,
             theta_s_der, theta_l_der, theta_1_der, theta_ders)
