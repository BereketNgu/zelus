(*
  This example is adapted from a Simulink model:
  https://fr.mathworks.com/help/simulink/examples/modeling-an-automatic-transmission-controller.html
*)

(** utils **)

let hybrid integrate_and_saturate(dx, x0, xmin, xmax) = x where
  rec der aux = dx init x0
  and x = max xmin (min xmax aux)

(** algorithm **)

let hybrid engine(ti, throttle) = rpm where
  rec te = Common.lookup_engine(throttle, rpm)
  and drpm = te -. ti
  and rpm = integrate_and_saturate (Common.engine_feedback_gain *. drpm, 1000., 600., 6000.)

let hybrid gearlogic(shift) = gear where
  rec init gear = 1.
  and automaton
      | First  ->
          do
          until shift(Common.UP)
            then do next gear = 2. in Second
      | Second ->
          do
          until shift(Common.DOWN)
            then do next gear = 1. in First
          else  shift(Common.UP)
            then do next gear = 3. in Third
      | Third  ->
          do
          until shift(Common.DOWN)
            then do next gear = 2. in Second
          else  shift(Common.UP)
            then do next gear = 4. in Fourth
      | Fourth ->
          do
          until shift(Common.DOWN)
            then do next gear = 3. in Third

let hybrid shiftlogic(speed, throttle) = gear where
  rec up_th = Common.lookup_interpup(throttle, gear)
  and dn_th = Common.lookup_interpdn(throttle, gear)

  and gear = gearlogic(shift)

  and automaton
      | SteadyState  ->
          do
          until up(dn_th -. speed) | (init) on (speed < dn_th)
            then DownShifting
          else up(speed -. up_th) | (init) on (speed > up_th)
            then UpShifting
      | DownShifting ->
          local t in
          do
            der t = 1. init 0.
          until up(speed -. dn_th)
            then SteadyState
          else up(t -. Common.twait)
            then do emit shift = Common.DOWN in SteadyState
      | UpShifting   ->
          local t in
          do
            der t = 1. init 0.
          until up(up_th -. speed)
            then SteadyState
          else up(t -. Common.twait)
            then do emit shift = Common.UP in SteadyState

let hybrid vehicle(out_torque, brake_torque) = (speed, trans_rpm) where
  rec final_drive_ratio = Common.p_final_drive_ratio *. out_torque
  and aux1 = final_drive_ratio -. signed_load
  and vehicle_inertia = Common.iv_inv *. aux1
  and der wheel_speed = vehicle_inertia
      init Common.p_initial_wheel_speed
  and linear_speed = Common.l_speed_coef *. wheel_speed
  and mph = Common.p_mph *. linear_speed
  and road_load = Common.p_drag_friction +. Common.p_aerodynamic_drag *. mph *. mph
  and sgn = Basics.bad_sgn mph
  and brake = brake_torque +. road_load
  and signed_load = sgn *. brake

  and trans_rpm = Common.p_final_drive_ratio *. wheel_speed
  and speed = mph

let hybrid autotrans(throttle, brake_torque) = (rpm, gear, speed) where
  rec rpm = engine(ti, throttle)
  and gear = shiftlogic(speed, throttle)
  and ti, out_torque = Common.transmission(rpm, gear, trans_rpm)
  and speed, trans_rpm = vehicle(out_torque, brake_torque)

let hybrid passing_maneuver() = throttle, brake_torque where
  rec brake_torque = 0.
  and init throttle = 60.
  and automaton
      | State1 ->
          do
            der throttle = -20. /. 14.9
          unless up(40. -. throttle)
            then State2
      | State2 ->
          do
            der throttle = 600.
          unless up(throttle -. 100.)
            then State3
      | State3 ->
          do
            der throttle = (58.8235 -. 100.) /. (50. -. 15.)
          unless up(-.throttle)
            then do next throttle = 0. in State4
      | State4 ->
          do
            der throttle = 0.
          done

let hybrid gradual_acceleration() = throttle, 0. where
  der throttle = (24. -. 13.4) /. 50. init 13.4

let hybrid hard_braking() = throttle, brake_torque where
  rec der t = 1. init 0.
  and init throttle = 50.
  and init brake_torque = 0.
  and present up(t -. 5.1) -> do throttle = 1. done
  and present up(t -. 10.) -> do brake_torque = 325. done

let hybrid coasting() = throttle, brake_torque where
  rec der t = 1. init 0.
  and init throttle = 80.
  and init brake_torque = 0.
  and present up(t -. 4.8) -> do throttle = 1. done
