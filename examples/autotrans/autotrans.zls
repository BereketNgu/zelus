(*
  This example is taken from Simulink:
  https://fr.mathworks.com/help/simulink/examples/modeling-an-automatic-transmission-controller.html
*)

(** constants, initial state **)

type shift = UP | DOWN

let pi = 4.0 *. atan 1.0

let iei = 0.0219914882835559         (* moment of inertia of the engine and the impeller *)
let engine_feedback_gain = 1. /. iei

let twait = 0.02                     (* minimal time between gear shifting *)

let p_final_drive_ratio = 3.23
let p_drag_friction = 40.
let p_aerodynamic_drag = 0.02
let p_wheel_radius = 1.
let p_vehicle_inertia = 12.09414785731247
let iv_inv = 1. /. p_vehicle_inertia

let initial_speed = 0.               (* initial speed of the vehicle (mph) *)

let p_mph = 60. /. 5280.             (* ft.min-1 to mph ratio *)
let l_speed_coef = 2. *. pi *. p_wheel_radius
let p_initial_wheel_speed = initial_speed /. p_mph /. l_speed_coef

(** utils **)

let hybrid integrate_and_saturate(dx, x0, xmin, xmax) = x where
  rec der aux = dx init x0
  and x = max xmin (min xmax aux)

let fun lookup_engine    (l, c) =
  Utils.lookup2D (Consts.line_engine,
                  Consts.col_engine,
                  Consts.vals_engine)
                  (l, c)
let fun lookup_interpup  (l, c) =
  Utils.lookup2D (Consts.line_interpup,
                  Consts.col_interpup,
                  Consts.vals_interpup)
                  (l, c)
let fun lookup_interpdn  (l, c) =
  Utils.lookup2D (Consts.line_interpdn,
                  Consts.col_interpdn,
                  Consts.vals_interpdn)
                  (l, c)
let fun lookup_factork   (l)    =
  Utils.lookup1D (Consts.line_factork,
                  Consts.vals_factork)
                  l
let fun lookup_torkratio (l)    =
  Utils.lookup1D (Consts.line_torkratio,
                  Consts.vals_torkratio)
                  l
let fun lookup_gear      (l)    =
  Utils.lookup1D (Consts.line_gear,
                  Consts.vals_gear)
                  l

(** algorithm **)

let hybrid engine(ti, throttle) = rpm where
  rec te = lookup_engine(throttle, rpm)
  and drpm = te -. ti
  and rpm = integrate_and_saturate (engine_feedback_gain *. drpm, 1000., 600., 6000.)

let hybrid shiftlogic(speed, throttle) = gear where
  rec up_th = lookup_interpup(throttle, gear)
  and dn_th = lookup_interpdn(throttle, gear)

  and init gear = 1.
  and automaton
      | First  ->
          do
          until shift(UP)
            then do next gear = 2. in Second

      | Second ->
          do
          until shift(DOWN)
            then do next gear = 1. in First
          else  shift(UP)
            then do next gear = 3. in Third

      | Third  ->
          do
          until shift(DOWN)
            then do next gear = 2. in Second
          else  shift(UP)
            then do next gear = 4. in Fourth

      | Fourth ->
          do
          until shift(DOWN)
            then do next gear = 3. in Third

  and automaton
      | SteadyState  ->
          do
          until up(dn_th -. speed) | (init) on (speed < dn_th)
            then DownShifting
          else up(speed -. up_th) | (init) on (speed > up_th)
            then UpShifting

      | DownShifting ->
          local t in
          do
            der t = 1. init 0.
          until up(speed -. dn_th)
            then SteadyState
          else up(t -. twait)
            then do emit shift = DOWN in SteadyState

      | UpShifting   ->
          local t in
          do
            der t = 1. init 0.
          until up(up_th -. speed)
            then SteadyState
          else up(t -. twait)
            then do emit shift = UP in SteadyState

let torque_converter(ne, nin) = (ti, tt) where
  rec speedratio = nin /. ne
  and factorK = lookup_factork speedratio
  and torqueratio = lookup_torkratio speedratio
  and quotient = ne /. factorK
  and impeller = quotient *. quotient
  and turbine = impeller *. torqueratio

  and ti = impeller and tt = turbine

let transmissionratio(tin, gear, nout) = (tout, nin) where
  rec gear_lookup = lookup_gear gear
  and tout = tin *. gear_lookup
  and nin  = nout *. gear_lookup

let transmission(ne, gear, nout) = (ti, tout) where
  rec ti, turbine_torque = torque_converter(ne, nin)
  and tout, nin = transmissionratio(turbine_torque, gear, nout)

let hybrid vehicle(out_torque, brake_torque) = (speed, trans_rpm) where
  rec final_drive_ratio = p_final_drive_ratio *. out_torque
  and aux1 = final_drive_ratio -. signed_load
  and vehicle_inertia = iv_inv *. aux1
  and der wheel_speed = vehicle_inertia
      init p_initial_wheel_speed
  and linear_speed = l_speed_coef *. wheel_speed
  and mph = p_mph *. linear_speed
  and road_load = p_drag_friction +. p_aerodynamic_drag *. mph *. mph
  and sgn = Basics.bad_sgn mph
  and brake = brake_torque +. road_load
  and signed_load = sgn *. brake

  and trans_rpm = p_final_drive_ratio *. wheel_speed
  and speed = mph

let hybrid autotrans(throttle, brake_torque) = (rpm, gear, speed) where
  rec rpm = engine(ti, throttle)
  and gear = shiftlogic(speed, throttle)
  and ti, out_torque = transmission(rpm, gear, trans_rpm)
  and speed, trans_rpm = vehicle(out_torque, brake_torque)

let hybrid passing_maneuver() = throttle, brake_torque where
  rec brake_torque = 0.
  and init throttle = 60.
  and automaton
      | State1 ->
          do
            der throttle = -20. /. 14.9
          until up(40. -. throttle)
            then State2
      | State2 ->
          do
            der throttle = 600.
          until up(throttle -. 100.)
            then State3
      | State3 ->
          do
            der throttle = (58.8235 -. 100.) /. (50. -. 15.)
          done

let hybrid gradual_acceleration() = throttle, 0. where
  der throttle = (24. -. 13.4) /. 50. init 13.4

let hybrid hard_braking() = throttle, brake_torque where
  rec der t = 1. init 0.
  and init throttle = 50.
  and init brake_torque = 0.
  and present up(t -. 5.1) -> do throttle = 1. done
  and present up(t -. 10.) -> do brake_torque = 325. done

let hybrid coasting() = throttle, brake_torque where
  rec der t = 1. init 0.
  and init throttle = 80.
  and init brake_torque = 0.
  and present up(t -. 4.8) -> do throttle = 1. done

open Scope

let hybrid main() =
  let rec der t = 1. init 0.

  and throttle, brake_torque = Draw.get_inputs()
  and rpm, gear, speed = autotrans(throttle, brake_torque) in

  present (period(0.1)) ->
    let () = Draw.draw(throttle, brake_torque, rpm, gear, speed) in

    let s1 = scope2(0.  , 325. , ("throttle", linear, throttle),
                                 ("brake torque", linear, brake_torque))
    and s2 = scope (0.  , 4.   , ("gear", linear, gear))
    and s3 = scope (0.  , 200. , ("speed", linear, speed))
    and s4 = scope (600., 6000., ("rpm", linear, rpm)) in

    window4("Autotrans", 50., t, s1, s2, s3, s4)
  else ()
