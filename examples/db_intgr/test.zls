(*
let hybrid calc (iy, x0,y0) = (x,ix) where
  rec automaton
      | State(v, y) ->
          do der x = x +. y init v
          until up (last x -. v -. 1.) then do emit ix = x in State (x,y)
          else up (last x -. v +. 1.) then do emit ix = x in State (x,y)
          else iy(y) then State (v, y)
  init State (x0, y0)
*)

let s = 400.
let kp = 0.4
let ki = 0.01
let q = 0.1

let hybrid calcx (newy, x0, y0) = x, newx where
  rec der x = fy init x0
  and init fx = x0
  and fy = present newy(y) -> y init y0
  and present newx(x) -> do next fx = x done
  and present up(x -. (fx +. q)) | up ((fx -. q) -. x) -> do emit newx = x done

let hybrid calcy (newx, y0, x0) = y, newy where
  rec der y = 100. -. (3. *. fx) -. (10. *. y) /. 7. init y0
  and init fy = y0
  and fx = present newx(x) -> x init x0
  and present newy(y) -> do next fy = y done
  and present up(y -. (fy +. q)) | up ((fy -. q) -. y) -> do emit newy = y done

open Scope

let atomic node plot (t,x) =
  let s = scope (0.0, 42.0, ("X", points true, x)) in
  window ("test", 50.0, t, s)





let hybrid main () = () where
  rec x, newx = calcx (newy, 0.0, 0.0)
  and y, newy = calcy (newx, 0.0, 0.0)
  and der t = 1.0 init 0.0
  and present (period (0.1)) -> do emit ok = () done
  and present newx(_) -> do _ = plot (t, x) done
