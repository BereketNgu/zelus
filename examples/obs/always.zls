open Scope
open Obs

let static tstep = 0.1

node main () =
    let rec t = 0. fby (t +. tstep) in

    let x =
             if (t > 5.) then sin(t) +. 2.
        else if (t > 4.) then sin(t) -. 2.
        else sin(t) +. 2.
    in

    let r1, s1 = d_always_l 3. (tstep, x) in
    let r2, s2 = d_always_l 5. (tstep, x) in
    let st1 = float_of_state s1 in
    let st2 = float_of_state s2 in

    let r3, s3 = d_always_r 6. (tstep, x) in
    let r4, s4 = d_always_r 3. (tstep, x) in
    let st3 = float_of_state s3 in
    let st4 = float_of_state s4 in

    let s1 = scope(-3., 3., ("x", linear, x)) in
    let s2 = scope2(-3., 3.,
        ("alwaysL(3) x", linear, r1),
        ("[state: 0 = NotYet 1 = Done]", linear, st1)) in
    let s3 = scope2(-3., 3.,
        ("alwaysL(5) x", linear, r2),
        ("[state: 0 = NotYet 1 = Done]", linear, st2)) in
    let s4 = scope2(-3., 3.,
        ("alwaysR(6) x", linear, r3),
        ("[state: 0 = NotYet 1 = Done]", linear, st3)) in
    let s5 = scope2(-3., 3.,
        ("alwaysR(3) x", linear, r4),
        ("[state: 0 = NotYet 1 = Done]", linear, st4)) in
    window5("Always", 10., t, s1, s2, s3, s4, s5)

hybrid main_c () =
    let der t = 1. init 0. in

    let v_true  = cos(t) +. 2. in
    let v_true_der = -. sin(t) in
    let v_false = sin(t) -. 2. in
    let v_false_der = cos(t) in

    let x_bool = present
        | up(t -. 5.) -> true
        | up(t -. 4.) -> false
        init true
    in
    let x = if x_bool then v_true else v_false in
    let x_der = if x_bool then v_true_der else v_false_der in

    let r1, st1 = c_always_l 3. (x, x_der) in
    let r2, st2 = c_always_l 5. (x, x_der) in

    let r3, st3 = c_always_r 6. (x, x_der) in
    let r4, st4 = c_always_r 3. (x, x_der) in

    present (period(tstep)) ->
        let s1 = scope(-3., 3., ("x", linear, x)) in
        let s2 = scope2(-3., 3.,
            ("alwaysL(3) x", linear, r1),
            ("[state: 0 = NotYet 1 = Done]", linear, float_of_state st1)) in
        let s3 = scope2(-3., 3.,
            ("alwaysL(5) x", linear, r2),
            ("[state: 0 = NotYet 1 = Done]", linear, float_of_state st2)) in
        let s4 = scope2(-3., 3.,
            ("alwaysR(6) x", linear, r3),
            ("[state: 0 = NotYet 1 = Done]", linear, float_of_state st3)) in
        let s5 = scope2(-3., 3.,
            ("alwaysR(4) x", linear, r4),
            ("[state: 0 = NotYet 1 = Done]", linear, float_of_state st4)) in
        window5("Continuous Always", 10., t, s1, s2, s3, s4, s5)
    else ()
