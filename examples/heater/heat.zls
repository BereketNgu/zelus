(* The Heater model presented by Nicolas Halbwachs during *)
(* a tutorial on Lustre, College de France, 2010. *)

(* Integrator Euler (forward) *)
(* for all n in Nat. x(0) = x0(0) and x(n) = x(n-1) + h * xprime(n-1) *)
let node euler(h)(x0, xprime) = x
  where rec x = x0 -> pre(x +. h *. xprime)

(* Model of a heater *)
(* (temp(n+1) - temp(n)) / h = alpha(n) * (c(n) - temp(n)) if u(n) *)
(*                             beta(n) * (temp_ext(n) - temp(n) otherwise *)
let node heater(h)(c, alpha, beta, temp_ext, temp0, u) = temp where
  rec temp =
    euler(h)(temp0, 
             if u then alpha *. (c -. temp) 
             else beta *. (temp_ext -. temp))

(* Relay (low/high threshold; a single boolean output *)
(* discrete time *)
let node relay(low, high, v) = u where
  rec u = if v < low then true
	  else if v > high then false
	  else false -> pre u

let node relay_bis(low, high, v) = u where
  rec u = present (v < low) -> true | (v > high) -> false init false
      
let node relay_six(low, high, v) = u where
  rec automaton
      | Low -> do u = false unless (v <= low) then High
      | High -> do u = true unless (v >= high) then Low
      end
      
let low = 1.0
let high = 1.0

let c = 50.0

let alpha = 0.1
let beta = 0.05

let h = 0.1

let max_time = 10.0 (* in secondes *)
    
(* Main program *)
let node system(reference) = (u, temp) where
  rec
      u = relay(reference -. low, reference +. high, temp)
  and
      temp = heater(h)(c, alpha, beta, 0.0, 0.0, u)

(* let node generic_system(controller)(reference) = (u, temp) where
  rec
      u = run controller(reference -. low, reference +. high, temp)
  and
      temp = heater(h)(c, alpha, beta, 0.0, 0.0, u)

let node system(reference) = generic_system(relay)(reference)
    *)
      
let node source(r) = Observers.piecewise_constant(0.0)(20.0)(r)
let node source2(r) = Observers.linear_constant(0.1)(0.0)(20.0)(r)

(* Oracle. Define the expected property *)
let node oracle(low, high, u, reference, measured) =
  (* inside the bound *)
  let outside = (measured < high) && (measured > low) in
  (* u must not oscillate *)
  let ok1 = not (Observers.oscillate(u)) in
  (* when [measured] is outside of the interval [low, high] and the reference *)
  (* does not change, the error must decrease *)
  let ok2 = if outside && (Observers.constant reference)
   then Observers.decrease(abs_float(reference -. measured)) else true in
  let ok3 = ok1 && ok2 in
  (* computes a new test when [measured] is inside for at least [enough] *)
  (* instants *)
  let inside_enough = Observers.count(h)(max_time, not outside) in
  ok3, inside_enough
 
(* Test of the system: connect a source generator, the system *)
(* and the oracle *)
let node test (manual_mode, input) = (u, reference, measured, ok) where
  rec reference =
      present manual_mode -> source(true -> last enough) else input
  and (u, measured) = system(reference)
  and ok, enough = oracle(low, high, u, reference, measured)

 
let node main_no_graphics() =
  let u, temp = system(19.0) in
  print_string "u = "; print_string (if u then "true" else "false");
  print_string "   ";
  print_string "temp = "; print_float temp;
  print_newline ();
  flush stdout

(* The main function. *)
let node main() =
  (* create a box for an input of type float; initially set at 19 degrees *)
  let init win_desc =
    Input.frame "Main"
      (Input.vbox [Input.make_float "temperature reference" (0.,68.) 19.;
		   Input.make_bool "manual mode" false]) in
  (* create and open the window *)
  let init w = Input.open_window("Inputs", win_desc) in
  (* by default the size of the window is the smallest size possible *)
  let init tmp = Input.resize_window(w, 400, 100) in
  (* read the input *)
  let reference_temp = Input.get_float (w, "temperature reference") in
  let manual_mode = Input.get_bool (w, "manual mode") in
  (* call the main function *)
  (* let u, reference_temp, measured_temp, ok = test(manual_mode, reference_temp) in *)
  let (u, measured_temp) = system(19.0) in
  let ok = false in
  let rec time = 0.0 -> pre time +. h in
  (* output the command and actual temperature *)
  let s =
    Scope.scope4
      (-1.0, 40.0,
       ("u", Scope.points true, if u then 1.0 else 0.0),
       ("input temp", Scope.linear, reference_temp),
       ("measured temp", Scope.linear, measured_temp),
       ("ok", Scope.points true, if ok then 1.0 else 0.0)) in
  Scope.window ("The Heater with a relay controller", 10.0, time, s)
