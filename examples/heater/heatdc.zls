(* The heater model. In this form, we lift the continuous-time *)
(* function Heatc.system into a discrete-time one that internalize the solver *)

(* compile with: 
 *- ocamlfind ocamlc bigarray.cma -package sundialsml \
    sundials.cma zllib.cma -I ../../lib heatc.ml heatdc.ml *)

open Heatc
open Node

(* counts the number of consecutive stops *)
let node stops status =
  let rec init c = 0
  and match status with
      | Success | StopTimeReached | TimeHasPassed | Error -> do c = 0 done
      | RootsFound | Horizon _ | Cascade -> do c = last c + 1 done
  in c
    
let node step (stop_time, time) = ok where
  rec ok = true -> (pre time < time) && (time < stop_time)
		    
let reference_temp = 19.0
let stop_time = 100.0
let h = 5.0
    
let node maindc () =
  let rec { time = time; status = status; result = (u, measured_temp) } =
    Node.solve Heatc.system 100.0 (next_horizon, reference_temp)
  and next_horizon =
    h -> if pre time >= pre (next_horizon) then pre(next_horizon) +. h
    else pre(next_horizon) in
  let s = 0 fby stops status in
  (* draw only when time change *)
  match step (stop_time, time) with
  | true ->
      let s =
	Scope.scope4
	  (-1.0, 40.0,
	   ("u", Scope.points true, if u then 1.0 else 0.0),
	   ("input temp", Scope.linear, reference_temp),
	   ("measured temp", Scope.linear, measured_temp),
	   ("stops", Scope.points true, float_of_int s)) in
      Scope.window ("The Heater with a relay controller", 10.0, time, s)
  | _ -> ()
	
