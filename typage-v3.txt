Objectif:

1/ Des calculs "compile time", e.g., les arguments des tableaux;
2/ Des calculs "instanciation time", e.g., on execute du code une
fois pour toute mais dont le resultat n'est pas connu a la compilation;
3/ Des calculs faits a chaque cycle.
4/ Du temps discret et du temps continu;
5/ Des calculs determistes, des calculs probabilistes.
6/ Des calculs a memoire, des calculs combinatoires.

On est naturellement conduit a faire du sous-typage. E.g., un
calcul statique peut etre utilise pour calculer une valeur a l'instanciation
qui peut elle-meme etre utilisee a chaque cycle. Une expression combinatoire
peut etre utilisee dans une expression a temps continu ou a temps discret. Une
expression deterministe peut etre utilisee dans une expression probabiliste.

Un systeme avec sous-typage est plus complexe. D'autant que l'on a un
systeme "a effet", c'est-a-dire que les fonctions ont des types de
la forme -k-> et qu'il faut du polymorphisme d'effet. C'est passablement
complique; necessite un algorithme de simplication des types; les messages
d'erreurs et la generation de code qui suivent sont egalement compliquee.

On va considerer deux propositions, toutes s'appuyant seulement sur
de l'unification.

Premiere proposition:
---------------------

sigma ::= forall a1,...,an. t | t
t     ::= t -> t -> ... -k-> t | t *...* t | a
       | (t,...,t) c

On prend des types n-aires pour les fonctions pour simplifier
la lecture/ecriture des types des fonctions.

k ::= m.k | not m.k | a

m ::= fun | node | det | proba
   |  discrete | continuous
   |  static | val | cycle
   |  det | proba
   
Exemples:

fun.det.discrete.a signifie "noeud sans memoire, deterministe, temps discrete"

node.det.continuous.a signifie "noeud a memoire, deterministe, temps continu".

Les types sont soumis a des regles de bonne formation.

L'intuition est que:

1/ not fun = node et not node = fun;
2/ not discrete = continuous; not continuous = det;
3/ not det = proba; not proba = det.
4/ c'est un peu plus complique pour { static, val, cycle } car il
y a trois elements. On peut donc preciser not static signifie que
le calcul est utilisable pendant l'instanciation ou a chaque cycle.

not (not (x)) = x; not (m1...mn).a = not(m1)....,not(mn).a

Règle de bonne formation. Intuition: on ne peut pas avoir
a la fois m et not m dans k.

|= k signifie que k est bien forme.

Trois regles:

|= k   k |= m
—————--------
 |= m.k
 
|= k   k |= not m
—————------------
 |= not m.k


 |= a
 

k |= m signifie que k ne contredit pas m.

not m |= m est un cas de contradiction. Ne devrait-on pas plutot definir
les cas de contradiction et dire que k est bien forme s'il ne contient pas
de contradiction ?



Typage des déclarations: On impose des simplifications, en particulier
parce qu'un noeud a memoire n'est pas implementee comme un noeud sans memoire;
qu'un noeud deterministe n'est pas implemente comme un noeud probabiliste.

(1) let f x1...xn = e

|-fun.det.k   "let" definit une fonction deterministe, sans memoire"

(2) let node f x1...xn = e

|-node.det.k "let node" definit une fonction deterministe, a memoire"

(3) let proba f x1...xn = e

|-fun.proba.k "definit une fonction probabiliste sans memoire"

(4) let proba node f x1...xn = e 

|-node.proba.k "definit une fonction probabiliste a memoire"

Rmq: on peut toujours rajouter des contraintes, par exemple que la
fonction est a temps discret ou a temps continu, qu'elle est statique
ou non.


(5) let static f = e

Dans un environnement courant H,

H on S.not A.not V. b |-fun.S.a. e : t

(6) fun x1 (static x2) ... x5 -> e

static indique que la valeur doit forcément être connu à la compilation. Pas à un autre moment. static est donc un raccourci pour S.not A.not V.a

Par contre, en hypothèse, on peut dire que a x2: t2.

k on k ... on k

H, k on ... on k x : t |-k x : t

Application:

H |-k f: t1 -> ... -> tm -k-> t
H |-k ei : ti
m <= n
———————————————-
H |-k f e1...en : tm+1 ->...-k-> t

H |- S.not A.not V. k e : t
————————————-
H |-a static e: t

H |-V.k e : t
—————————-
H |-not S.k’ value e: t

On sait que si V, alors il n’y a pas de contraintes en terme de temps (discret ou continu), ni en terme de déterminisme, probabiliste.



Deuxieme proposition:
---------------------


H ::= [s1 x1: t1;...;sn xn: tn]
H |-k e : t

k ::= {det:d; fun:f; time:t; safe:a}
d ::= Det | Proba | 'a
f ::= Fun(s) | Node
t ::= Hybrid | Discrete | 'c
a ::= Safe | Unsafe | 'd
s ::= Static | Val | Dyn | 'e


Conventions d'affichage:

-S-> versus -V-> versus -> versus -'a-> pour les fonctions;

=> pour les noeuds;

~> pour les fonctions "probabilistes"; ~=> pour les noeuds "probabilistes"

Pour ne pas avoir des types monstrueusement compliques, adopter une
notation avec un peu de partage, par exemple:

val f : Hybrid('a). int -'a-> bool -'a-> int * int

ou

static f : Hybrid('a). int -h('a)-> bool -'a-> int * int

s ::= S | V | A (* S pour static = compile-time; V pour val = instanciation; A pour
                         any = dynamic *)
k ::= S | V | A | M (* ... M pour memory = stateful *)
p ::= D | P (* D pour deterministic; P pour probabilistic *)

-pk-> avec la convention d'affichage:

-DS->; -DV->; -DA-> simplement ->; -DM-> par =>
-PS-> par ~S~>; -PV-> par ~V~>; -PA-> par ~>; -PM-> par ~=>


\begin{verbatim}
  t ::= t -ps-> t | t * ... * t | 'a | (t,...,t) bt
  sigma ::= 'a1,...,'an. 'b1,...,'bm.'c1,...,'cr.t

  k ::= S | V | A(tau) | 'b
  p ::= proba | det
  s ::= node(tau) | fun(k)
  tau ::= D | C | 'c

  node(D): a etat, temps discret; -D=>
  node(C): a etat, temps discret; -C=>
  node('c): a etat, quand on veut; -'a=>
  fun(S): sans memoire, temps statique; -S->
  fun('b): sans memoire, statique ou non; -'b->
  fun(A('c)): sans memoire; -A'a->
  fun(A(D)): sans memoire, discret; -AD-> 
  fun(A(C)): sans memoire, continu; -AC->

  H ::= [k x : t;...; k x : t]

  H |-s e : t
  
  H, A(tau) x : t1 |-node(tau) e: t2
---------------------------------------------
H |-s node f x = e : [f : t1 -node(tau)-> t2]

  H, k x : t1 |-fun(k) e: t2
--------------------------------------------
H |-s fun f x = e : [f : t1 -fun(k)-> t2]

  H |-fun(S) e1: t1  H, 'b x: t1 |-s(k) e2 : t2
-----------------------------------------------
H |-s let static x = e1 in e2 : t2


  H |-s f: t1 -fun(k)-> t2  H |-s by k e : t1     
-----------------------------------------------
    H |-s f e : t2

avec node(tau) by A(tau) = node(tau)
et   fun(k) by k = fun(k)

indefini sinon.


    H |-fun(S) f: t1 -node(tau)-> t2  H |-node(tau) e : t1
----------------------------------------------------------
  H |-node(tau) run f e : t2

      H |-node(tau) f: t1 -node(tau)-> t2  H |-node(tau) e : t1
---------------------------------------------------------------
  H |-node(tau) restart f e : t2

  
  H, k x : t |-node(tau) x: t

  H, k x : t |-fun(k) x: t

  H |-s c: t

    H |-s E1: H1  H |-s E2: H2
------------------------------------
  H |-s E1 and E2: H1+H2

      H |-s p : t   H |-s e : t k = intro(s)
--------------------------------------------
      H |-s p = e: [k p : t]

avec intro(node(tau)) = A(tau)
et intro(fun(k)) = k

 H, s(H0) |-s E : s(H0)   H, s(H0) |-s e : t
--------------------------------------------
H |-s letrec E in e : t

avec node(tau)([A tau1 x1 : t1;...; A taum xm : tm])
et   fun(k)([k x1 : t1;...; k xm : tm])


 H |-discrete(s) E1 : H'   H |-s E2 : H'
-----------------------------------------
  H |-s present e -> E1 else E2: H'

  avec discrete(node(tau)) = node(D)
  et   discrete(fun(A(tau))) = fun(A(D))

 H |-s e : t  H |-s E1 : H'   H |-s E2 : H'
-------------------------------------------
  H |-s if e then E1 else E2: H'
\end{verbatim}


